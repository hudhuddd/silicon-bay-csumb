import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;


public class Assig6 {
	static HandTable table;
	static Timer timer;
	
	public static void main(String[] args) {
		table = new HandTable("something");
		table.setSize(500, 300);
	    table.setLocationRelativeTo(null);
        table.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        timer = new Timer(table); 
        table.setVisible(true);
	}
}

class CardTable extends JFrame
{

   public JPanel pnlTimer;

   /**
    * The constructor filters input, adds any panels to the JFrame, and
    * establishes layouts according to the general description below.
    * 
    * @param title The title for the window
    * @param numCardsPerHand the number of cards per hand
    * @param numPlayers the number of players
    */
   public CardTable(String title)
   {
      String frameTitle = filterTitle(title);

      pnlTimer = new JPanel();

      setLayout(new BorderLayout(10, 10));
      add(pnlTimer, BorderLayout.CENTER);

      pnlTimer.setBorder(new TitledBorder("Timer"));
   }

   /**
    * Verify input, if invalid do error correction and return a valid input.
    * 
    * @param title the unverified title.
    * @return a string will be returned. If input was valid then it will be
    *         returned, otherwise some default string is returned.
    */
   private String filterTitle(String title)
   {
      if (title.length() == 0)
         return "GUI Card Game";
      return title;
   }
}

/*
 * extends CardTable to allow it to be responsive to changes fired from the
 * game.
 */
class HandTable extends CardTable
{
   //adds to default constructor a parameter and addTimerPanel call
   //need to do this to the extended constructor too
   public HandTable(String title)
   {
      super(title);
   }

}

/*
 * class defines the display and methods for graphic timer to run
 * in a card table. calling object or program must have a handtable
 * (or child class) object with a JPanel pnlTimer data member, as this
 * class will modify the handtable display to update the graphic timer.
 * table must also have clearTimerArea() and addTimerPanel() methods
 */
class Timer extends Thread {
   private JButton startstop = new JButton("Start / Stop");
   public TimerFace face;
   public HandTable table;
   private boolean clicked = false;
   private int seconds = 0;
   private static int NUM_DIGITS = 10;
   private static Icon[] clockNums = new ImageIcon[NUM_DIGITS];//holds num icons
   private static Icon dots;//holds ':' icon
   private static boolean iconsLoaded = false; //ensures icons are only loaded once
   private static int FACE_WIDTH = 5; //5 icons on clock face
   private static JLabel[] timerPanels = new JLabel[FACE_WIDTH];//panels that hold the icons
   private static int clockBrain[] = {0, 0, 0, 0, 0}; //controls the calculation
	
   Timer(HandTable table)
   {
      this.table = table;
      Timer.loadClockIcons();
      face = new TimerFace(table);
      TimerListener listener = new TimerListener();
      startstop.addActionListener(listener);
   }
	
   private static void loadClockIcons()
   {
      String num;
      if (!iconsLoaded)
      {
         String relativePath = "./clocknums/";
         String extension = ".png";
         for (int j = 0; j < NUM_DIGITS; j++)
         {
            num = Integer.toString(j);
            ImageIcon image = new ImageIcon(relativePath + num + extension);
            clockNums[j] = image;
         }
         dots = new ImageIcon(relativePath + "X" + extension);
         iconsLoaded = true;
      }
   }
   
   private void updateClock(HandTable table)
   {
      if(seconds == 5999)
         clicked = false;  //ensures clock can't run over what fits on the clock face
      if(clicked)
         clockBrain[4]++;//so clock does not advance if start has been pressed
      if(clockBrain[4] == 10)
      {
         clockBrain[4] = 0;
         clockBrain[3]++;
      }
      if(clockBrain[3] == 6)
      {
         clockBrain[3] = 0;
         clockBrain[1]++;
      }
      if(clockBrain[1] == 10)
      {
         clockBrain[1] = 0;
         clockBrain[0]++;
      }
      
      face.updateClockFace(table, clockBrain);
   }
   
   
   //pauses thread for 999 milliseconds before updating clock face
   private void doNothing(int milliseconds)
   {
      try
      {
         Thread.sleep(milliseconds);
      }
      catch(InterruptedException e)
      {
         System.out.println("Unexpected interrupt");
         System.exit(0);
      }      
   } 
   
   
   public void run()
   {
      while (seconds < 1800) //max time on timer is 30 minutes
      {
         if(clicked)
         {
            doNothing(999);
            updateClock(table);
            seconds++;
         }
         else
         {
            updateClock(table);
            break;
         }
      }
   }
   
   /*
    * creates an action listener for the start/stop button. if button
    * has never been clicked, it fires run and changes clicked to true
    * if clicked again(while click is true), it changes clicked to false
    * so that run() breaks out of the update loop
    */
   private class TimerListener implements ActionListener
   {
      public void actionPerformed(ActionEvent e)
      {
         if(!clicked){
            clicked = true;
            start();       
         }
         else
            clicked = false;//causes run to break out of loop
      }
   }
   
   /*TimerFace extends JPanel and handles all updates to the 
    * clock GUI display 
    */
   private class TimerFace extends JPanel
   {
      JPanel timerFace = new JPanel(new GridLayout(2,1));
      JPanel numbers;

      //constructor loads the clock face onto the calling HandTable
      TimerFace(HandTable table)
      {
         loadDisplay(table);
      }
	   
      //creates the clock face jpanel and fills it with all 0 icons
      //adds it to the passed HandTable
      private void loadDisplay(HandTable table)
      {
         
         numbers = new JPanel(new FlowLayout());
         timerFace.setSize(100, 50);
	
         for(int i = 0; i < FACE_WIDTH; i++)
         {
            if(i != 2)
               timerPanels[i] = new JLabel(clockNums[0]);
            else
               timerPanels[i] = new JLabel(dots);
            numbers.add(timerPanels[i]);
         }
         timerFace.add(numbers);
         timerFace.add(startstop);
         addTimerPanel(table);
      }
	   
      //clears the timer face, updates icon to reflect the updated
      //clockbrain values, clears and replaces the timer on the 
      //playing table
      private void updateClockFace(HandTable table, int[] clock)
      {
         timerFace.removeAll();
         numbers.removeAll();
         for(int i = 0; i < FACE_WIDTH; i++)
         {
            if(i != 2)
               timerPanels[i] = new JLabel(clockNums[clock[i]]);
            numbers.add(timerPanels[i]);
         }
         
         timerFace.add(numbers);
         if(clicked)
            timerFace.add(startstop);

         clearTimerArea(table);
         addTimerPanel(table);
         table.revalidate();
         table.repaint();
      }
	   
      //receives the HandTable object and adds the timerFace to the 
      //designated timer panel
      public void addTimerPanel(HandTable table)
      {
         table.pnlTimer.add(timerFace);
      }
	   
      // resets timer area display on playing table
      private void clearTimerArea(HandTable table)
      {
         table.pnlTimer.removeAll();
      }
   }
}


